# Category Dictionary Editor Plan

## Context
- Users want to directly manage the `category_dictionary.json` so they can review existing description-to-category associations, add new ones, modify mistakes, and delete outdated entries without leaving BOQ Tools.
- The workflow must also support bulk maintenance: the user wants to search or filter descriptions, multi-select the matches, and apply a category change or deletion across all selected items in one action.

## Targeted Files
- `core/category_dictionary.py`: expose structured access to mappings, add bulk-friendly update/remove helpers, and ensure persistence/backup logic supports UI edits.
- `ui/main_window.py`: add an entry point (menu/toolbar command) that launches the dictionary editor dialog.
- `ui/category_dictionary_manager.py` (new): implement the dedicated dialog with list view, filtering, inline edits, bulk operations, and save/cancel handling.
- `utils/config.py`: confirm helpers for resolving the user-specific path already exist; extend only if the new dialog needs additional backup location helpers.
- `tests/` (new or existing module): add regression coverage for the new core helpers and persistence behaviours.

## Implementation Steps
1. **Data Access & Safety**
   - Extend `CategoryDictionary` with a `list_mappings()` method that returns immutable snapshots (e.g., list of dicts with description/category/confidence/notes/usage_count) sorted for deterministic display.
   - Add helper methods for bulk updates: `upsert_mappings(mapped_pairs)`, `delete_mappings(descriptions)`, and an optional `rename_category_for_descriptions(descriptions, new_category)` that internally normalizes descriptions, updates `self.categories`, and reuses existing single-item logic.
   - Ensure deletes prune empty categories when no mappings reference them, and add a `backup_current_file()` helper that copies the current JSON to a timestamped file in the same directory before overwriting.

2. **Dialog UI & Interaction**
   - Create `CategoryDictionaryManager` dialog with a `ttk.Treeview` (or `ttk.Treeview` + `ttk.Style`) configured for multi-select; columns should include Description, Category, Confidence, Notes, and Usage Count.
   - Preload options for the category dropdown using `CategoryDictionary.get_all_categories()`, and surface a text filter entry that performs case-insensitive substring matching across description & category while keeping pagination light enough for large dictionaries.
   - Provide inline editing affordances: double-click to edit a single row (opens a modal with combobox for category, optional confidence/notes inputs, and validation that descriptions are non-empty). Include an “Add Mapping” button that opens the same editor initialized with blank values.

3. **Bulk Operations**
   - Track multi-selection state; enable bulk action buttons (“Set Category…”, “Delete Selected”) only when there are selections.
   - For “Set Category…”, show a dialog that lets the user pick an existing category or enter a new one; apply the choice to all selected descriptions through the new bulk helper.
   - For “Delete Selected”, prompt for confirmation, delete via the new helper, and refresh the grid while maintaining filter criteria so users see the updated list.

4. **Persistence & UX Guardrails**
   - Maintain an in-memory “dirty” flag; when edits occur, enable a `Save` button that calls `backup_current_file()`, then `save_dictionary()`, and reloads from disk to reflect the canonical state.
   - Implement `Cancel`/close behaviour that warns about unsaved edits and offers to Save/Discard/Return.
   - Surface status feedback (e.g., `ttk.Label` or messagebox) summarizing counts of added/updated/deleted mappings after each save, and log the same via the existing logger.

5. **Integration & Tests**
   - Wire a “Manage Category Dictionary” command into `main_window` (menu or toolbar) that instantiates the new dialog, passing the Tk root as parent and a shared `CategoryDictionary` instance to avoid redundant reloads.
   - Add unit tests around the new bulk helpers (e.g., verify normalization, category pruning, backup creation) using temporary directories to isolate JSON writes, and extend UI smoke/integration tests if feasible to confirm the command can launch (headless-friendly checks).




