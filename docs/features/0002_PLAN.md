# Comparison BOQ Row Categorization Plan

## Context
Currently, when a master BOQ is loaded and processed, row categorization happens after sheet/column/row mapping while the data structure still maintains sheet-level organization (with `row_classifications` per sheet). However, when comparison BOQs are loaded via "Compare Full Process", new rows are added to the unified dataset but do not get categorized. These uncategorized rows are exported to Excel but have no categories and therefore do not sum up in the category summary. The Summarize function filters by Category, so uncategorized rows are excluded from category totals. The user wants to be able to categorize new rows from comparison BOQs after they are merged/added, using the same categorization workflow as master BOQ.

## Proposed Unified Approach
Instead of maintaining two different categorization paths (sheet-based for master, DataFrame-based for comparison), refactor the categorization workflow to **always work on DataFrame elements**. This means:
- **Master BOQ**: After sheet/column/row mapping is complete, build the DataFrame first (as currently done in `_on_confirm_row_review()`), then categorize on the DataFrame
- **Comparison BOQ**: After comparison rows are merged, filter to uncategorized rows and categorize on the DataFrame
- **Unified workflow**: Both master and comparison use the exact same categorization logic - the only difference is that comparison filters to uncategorized rows before categorizing
- **Sheet information preserved**: The `Source_Sheet` column in the DataFrame maintains sheet information, so categorization doesn't need the sheet structure

## Key Differences (Current State)
- **Master BOQ categorization**: Works on data that is still organized by sheets with `row_classifications` structure (`file_mapping.sheets[].row_classifications[]`)
- **Comparison BOQ data**: Already converted to unified DataFrame structure (no sheet organization) via `_create_unified_dataframe()`
- **New rows from comparison**: Added via `ComparisonEngine.ADD()` which explicitly sets category to empty string (line 318 in `core/comparison_engine.py`)

## Targeted Files

### Primary Changes
- `ui/main_window.py`: 
  - `_on_confirm_row_review()` method (around line 2025): **Refactor** - After building DataFrame from sheets, pass DataFrame directly to categorization (instead of file_mapping with sheet structure)
  - `_start_categorization()` method (around line 2123): **Refactor** - Accept DataFrame directly instead of building from `file_mapping.sheets`
  - `_compare_full()` method (around line 2318): Add categorization step after comparison rows are processed - filter to uncategorized rows, then categorize
  - `_update_main_dataset_with_comparison_results()` method (around line 2696): After updating dataset, check for uncategorized rows and trigger categorization
  - `_on_categorization_complete()` method (around line 2142): Handle categorization completion for both master and comparison workflows (unified)

- `ui/categorization_dialog.py`:
  - `CategorizationDialog.__init__()` (around line 19): **Refactor** - Always accept DataFrame directly (remove sheet-based DataFrame building logic)
  - `_start_categorization()` method: **Simplify** - Work directly with DataFrame, no need to detect sheet vs DataFrame structure
  - Methods that build DataFrame from `file_mapping.sheets`: **Remove or refactor** - DataFrame should be built before calling categorization dialog

- `core/comparison_engine.py`:
  - `ADD()` method (around line 214): Currently sets category to empty string - this is correct, categorization happens later
  - No changes needed here, but verify that empty categories are preserved

### Supporting Files (Review/Verify)
- `main.py`: `_create_dataframe_from_mapping()` method (around line 438): Understand how master DataFrame is created from sheet structure (this logic may be moved to `_on_confirm_row_review()`)
- `ui/main_window.py`: `_summarize_categorized_data()` method (around line 4586): Verify it filters by Category column correctly (uncategorized rows excluded from category totals)

## Implementation Steps

### Phase 1: Refactor Master BOQ Categorization to Use DataFrame

1. **Refactor `_on_confirm_row_review()` to build DataFrame first**
   - Current logic already builds `final_dataframe` from sheets (around line 2112)
   - Store this DataFrame in `file_mapping.filtered_dataframe` (already done)
   - **Change**: Pass the DataFrame directly to `_start_categorization()` instead of passing `file_mapping` with sheet structure
   - Keep the DataFrame building logic as-is (it already creates the unified structure)

2. **Refactor `_start_categorization()` to accept DataFrame**
   - **Change signature**: Accept `dataframe` parameter directly instead of building from `file_mapping.sheets`
   - Remove logic that builds DataFrame from sheet structure
   - Pass DataFrame directly to `show_categorization_dialog()`
   - Update call sites in `_on_confirm_row_review()` to pass DataFrame

3. **Refactor `CategorizationDialog` to always work with DataFrame**
   - **Change `__init__()`**: Accept `dataframe` parameter directly (instead of `file_mapping`)
   - Remove all logic that builds DataFrame from `file_mapping.sheets`
   - Simplify: Always work with the provided DataFrame
   - Ensure DataFrame has required columns (Description, code, unit, quantity, unit_price, total_price, Category, Source_Sheet)
   - Update `show_categorization_dialog()` function signature to accept DataFrame

4. **Update `_on_categorization_complete()` for unified handling**
   - Accept categorized DataFrame and update `file_mapping.dataframe` (or `file_mapping.filtered_dataframe`)
   - Works the same for both master and comparison workflows
   - Refresh UI and enable Summarize/Export functionality

### Phase 2: Integrate Categorization into Comparison Workflow

5. **Add categorization step in `_compare_full()`**
   - After `_update_main_dataset_with_comparison_results()` (around line 2535), check if there are uncategorized rows
   - Identify uncategorized rows: Filter DataFrame where Category column is empty/null/NaN
   - If uncategorized rows exist:
     - Extract uncategorized rows DataFrame
     - Call `_start_categorization()` with the uncategorized rows DataFrame
     - After categorization completes, merge categorized results back into main dataset

6. **Handle categorization completion for comparison**
   - In `_on_categorization_complete()`: The callback already handles DataFrame updates
   - Merge categorized results back into `file_mapping.dataframe` by matching row indices or unique identifiers
   - Update `processor.master_dataset` if still in memory
   - Refresh UI to show updated categories
   - Same logic as master BOQ - no special handling needed

7. **Add validation/warning for uncategorized rows**
   - Before allowing Summarize:
     - Check if DataFrame has any rows with empty/null Category
     - If found, show warning dialog: "Some rows are not categorized. These will be excluded from category totals in Summarize. Would you like to categorize them now?"
     - Provide option to start categorization or proceed anyway
   - Note: Export Data will still export uncategorized rows (they just won't appear in category summary)

### Phase 3: User Experience Enhancements

8. **Unified categorization UX**
   - Master and comparison use the exact same categorization dialog and workflow
   - Same dialog appearance and functionality
   - For comparison: Only difference is that uncategorized rows are filtered before categorization
   - Show progress and status messages appropriately

9. **Update status messages**
   - After comparison merge: "Comparison completed. X new rows need categorization."
   - During categorization: "Categorizing X rows..." (works for both master and comparison)
   - After categorization: "Categorization complete. All rows are now categorized."

## Algorithm Details

### Building DataFrame for Master BOQ (in `_on_confirm_row_review()`)
```python
# Current logic already builds DataFrame from sheets
# This logic remains unchanged, just pass DataFrame to categorization
final_dataframe = pd.DataFrame(rows)  # Already built from sheet structure
file_mapping.filtered_dataframe = final_dataframe
# NEW: Pass DataFrame directly instead of file_mapping
self._start_categorization(final_dataframe, file_mapping)
```

### Identifying Uncategorized Rows (for Comparison)
```python
# After comparison merge, identify rows needing categorization
uncategorized_mask = (
    updated_df['Category'].isna() | 
    (updated_df['Category'] == '') | 
    (updated_df['Category'].astype(str).str.strip() == '')
)
uncategorized_rows = updated_df[uncategorized_mask].copy()

# If uncategorized rows exist, categorize them
if len(uncategorized_rows) > 0:
    self._start_categorization(uncategorized_rows, file_mapping)
```

### Updating Dataset After Categorization
```python
# For master BOQ: Update file_mapping.filtered_dataframe directly
# For comparison: Merge categorized results back into main dataset
# Match by index (if preserved) or unique identifier (Description + code combination)
# Update Category column for matching rows

# Example for comparison:
categorized_df = ...  # From categorization dialog
# Find matching rows in main dataset and update Category
for idx, row in categorized_df.iterrows():
    # Match by Description + code or use original index
    main_df.loc[main_df['Description'] == row['Description'] & 
                main_df['code'] == row['code'], 'Category'] = row['Category']
```

## Edge Cases to Handle

1. **No new rows from comparison**: Skip categorization step entirely
2. **All new rows already have categories**: Verify this shouldn't happen (ADD sets category to empty), but handle gracefully
3. **User cancels categorization**: Allow them to proceed but warn about uncategorized rows in Summarize
4. **Multiple comparison BOQs loaded sequentially**: Each new comparison may add uncategorized rows - categorize after each merge
5. **Master BOQ rows also uncategorized**: With unified approach, same categorization flow handles both master and comparison uncategorized rows
6. **DataFrame structure differences**: Ensure comparison DataFrame has same column structure as master (should be guaranteed by `_create_unified_dataframe()`)
7. **Source_Sheet column**: Ensure it's preserved in DataFrame for both master and comparison (already present in current implementation)

## Notes

- **Unified workflow benefit**: By always working on DataFrame, master and comparison categorization use identical logic - simpler to maintain and test
- **Sheet information**: The `Source_Sheet` column in DataFrame preserves sheet information, so categorization doesn't need sheet structure
- **Export Data behavior**: Uncategorized rows ARE exported to Excel, they just don't appear in category summary totals
- **Summarize behavior**: Uncategorized rows are excluded from category totals (filters by Category column)
- **Comparison categorization**: Should be optional but recommended (with warning if skipped)
- Consider adding a "Categorize New Rows" button in the UI that can be triggered manually after comparison
- The refactoring simplifies the codebase by removing dual code paths (sheet-based vs DataFrame-based)

